#!/usr/bin/python3
import argparse
import subprocess
import sys
import os
import shlex

default_http_local_port  = 5000
default_https_local_port = 5001
bassenthwaite_port       = 1022

# Access an ssh tunnel to remote host
def access_tunnel(args):
    if not check_port(args):
        sys.exit()
    ssh_command = "/usr/bin/ssh -p {port} -l {user} tunnel -L{http}:127.0.0.1:80 -L{https}:127.0.0.1:443".format(
            port=args.port,
            user=args.remoteuser,
            http=args.httplocal,
            https=args.httpslocal)
    print(ssh_command)
    os.system(ssh_command)
    sys.exit()

# Returns list of strings containing details of currently open tunnels
def find_tunnels():
    HOST = "bassenthwaite"
    PORT = "-p %s" % bassenthwaite_port
    COMMAND = "/usr/bin/whot"

    ssh_subprocess = subprocess.Popen(["/usr/bin/ssh", HOST, PORT, COMMAND],
                           shell=False,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
    tunnels = ssh_subprocess.stdout.readlines()
    if tunnels == []:
        errors = ssh_subprocess.stderr.readlines()
        for error in errors:
            error = error.decode("ascii").rstrip()
            print("ERROR: %s" % error, file=sys.stderr)
        sys.exit()
    else:
        return [tunnel.decode("ascii").rstrip() for tunnel in tunnels]

# Prints list of currently open tunnels
def list_tunnels(args):
    tunnels = find_tunnels()
    for tunnel in tunnels[1:]: #skip first line as it is never a tunnel
        print(tunnel)

# Helper for port_checker
# Checks to see if a port is open on given port
# Returns string of tunnel info if tunnel is open, empty string if not
def is_tunnel_open(port):
    port = "Tunnel: %s " % str(port)
    tunnels = find_tunnels()

    for tunnel in tunnels:
        if port in tunnel:
            return tunnel;

# check if there is an organization name listed for the tunnel by parsing tunnel entry
# assumes balanced parentheses in organization names and that organization name is in parentheses
# expected tunnel format:
#    Tunnel: <port> from <ip> (<organization>) (pid: <port>)
def is_tunnel_linked_to_organization(tunnel):
    open_parens = 0
    first_paren_index = tunnel.find("(")
    index = first_paren_index
    result = False
    for c in tunnel[first_paren_index:]:
        index += 1
        if c == '(':
            open_parens += 1
        elif c == ')':
            open_parens -= 1
            if open_parens == 0:
                last_paren_index = index
                break
    organization = tunnel[first_paren_index+1:last_paren_index-1].strip()
    if (organization):
        result = True
    return result

# Tells user if a tunnel is open on args.port
# Warns if organization name is missing from bassenthwaite:/etc/tunnels.txt
def check_port(args):
    result = False
    tunnel = is_tunnel_open(args.port)
    if tunnel:
        print(tunnel)
        if (not is_tunnel_linked_to_organization(tunnel)):
            print("WARNING: Organization name missing from bassenthwaite:/etc/tunnels.txt");
        result = True
    else:
        print("No tunnel open on port %d.\nTo see available tunnels, use \'tnl l\'." % args.port)
    return result

parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title="commands", help="command help")

# Arguments for accessing a tunnel
parser_tunnel = subparsers.add_parser("access", aliases=["a"], help="access an open tunnel")
parser_tunnel.add_argument("port", type=int, help="port of tunnel")
parser_tunnel.add_argument("remoteuser", type=str, help="user on remote host")
parser_tunnel.add_argument("-H", "--httplocal", type=int, default=default_http_local_port,
                           help="local port to bind remote port 80 to (default %s)" % default_http_local_port)
parser_tunnel.add_argument("-S", "--httpslocal", type=int, default=default_https_local_port,
                           help="local port to bind remote port 443 to (default %s)" % default_https_local_port)
parser_tunnel.set_defaults(func=access_tunnel)

# Arguments to list open tunnels
parser_list = subparsers.add_parser("list", aliases=["l"], help="list open tunnels")
parser_list.set_defaults(func=list_tunnels)

# Arguments to check a port for open tunnels
parser_check_port = subparsers.add_parser("check", aliases=["c"], help="check to see if a port has a tunnel open on it")
parser_check_port.add_argument("port", type=int, help="port to check")
parser_check_port.set_defaults(func=check_port)

args = parser.parse_args()
args.func(args)
